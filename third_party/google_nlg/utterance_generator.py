# Copyright 2021 Google Research.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Generates template based utterances based on user and system actions.

A template is defined for a few categories of actions for each service. First,
each action is converted into a sentence by with the help of the corresponding
template, optionally replacing the parameters with the associated slot values.
The utterance is generated by concatenating the template based representations
of each action present in the turn.
"""

import os

VALUE_CHAR = "@"
SEPARATOR = "!!"
CONFIRM_PREFIX = "Please confirm the following details:"

# The precedence order used for sorting actions before generating a templatized
# utterance.
ACT_PREFERENCE_ORDER = ("SELECT", "INFORM_COUNT", "NOTIFY_SUCCESS",
                        "NOTIFY_FAILURE", "INFORM", "REQUEST", "CONFIRM")

# The acts for which the selected template also depends on the intent.
INTENT_CONDITIONED_ACTS = frozenset(
    ["NOTIFY_FAILURE", "NOTIFY_SUCCESS", "INFORM_COUNT", "OFFER_INTENT"])


def get_action_template(action, intent):
  """Returns a templatized representation of an action.

  For an action like INFORM(city=Napa) the return value is of the form:
  INFORM<SEPARATOR>city<SEPARATOR><VALUE_CHAR>. One occurrence of VALUE_CHAR
  indicates that the template handles the case when one value is passed.

  Args:
    action: DialogAction to be converted into a template.
    intent: The intent corresponding to the action.

  Returns:
    String template constructed as mentioned above.
  """
  parts = [action["act"]]
  if action["act"] in INTENT_CONDITIONED_ACTS:
    if intent is None:
      raise ValueError("Intent is required for an intent conditioned act.")
    # Add the intent to the template key.
    parts.append(intent)
    if action["act"] == "INFORM_COUNT":
      parts.extend(["count", VALUE_CHAR])
  elif action["slot"]:
    # Add the slot to the template key.
    parts.append(action["slot"])
    # Add placeholder for values. For boolean slots, add the actual value.
    slot_values = action["values"]
    if slot_values:
      # Check for True, False and dontcare values.
      if slot_values[0] in ["True", "False", "dontcare"]:
        if len(slot_values) != 1:
          raise ValueError("Boolean slots can't have multiple values.")
        parts.append(slot_values[0])
      else:
        parts.append(VALUE_CHAR * len(slot_values))
  return SEPARATOR.join(parts)


class TemplateUtteranceGenerator:
  """Generates template utterance for a dialogue turn."""

  def __init__(self, template_dir, use_canonical_values=False):
    self._template_dir = template_dir
    self._templates_for_service = {}
    act_pref = {v: k for k, v in enumerate(ACT_PREFERENCE_ORDER)}
    # Key function used for sorting actions based on the preference order of
    # dialogue acts.
    self._act_key_fn = lambda action: act_pref.get(action["act"], len(act_pref))
    self._use_canonical_values = use_canonical_values

  def _load_templates_for_service(self, service):
    """Load utterance templates for a service from the tsv file."""
    tsv_path = os.path.join(self._template_dir, "{}.tsv".format(service))
    if not os.path.exists(tsv_path):
      raise ValueError("Templates not defined for service: {}.".format(service))
    act_key_to_template = {}
    with open(tsv_path) as f:
      for line in f:
        act_key, template_str = line.strip().split("\t")
        # Verify that the act_key and template_str are consistent.
        if act_key.count(VALUE_CHAR) != template_str.count(VALUE_CHAR):
          raise ValueError(
              "Template not consistent. act_key: {} template: {}".format(
                  act_key, template_str))
        act_key_to_template[act_key] = template_str
    self._templates_for_service[service] = act_key_to_template

  def _get_intent(self, action, frame):
    if action["act"] == "OFFER_INTENT" and action["slot"] == "intent":
      return action["values"][0]
    return frame.get("service_call", {}).get("method", None)

  def _get_utterance_for_action(self, service, intent, action, schema=None):
    """Converts an action to an utterance and also identifies slot spans.

    Args:
      service: The service corresponding to the action.
      intent: The intent corresponding to the action.
      action: A json object containing a dialogue action.
      schema: if given API schema, do lexicalization based on the schema

    Returns:
      The robot utterance corresponding to the action.
    """
    if service not in self._templates_for_service:
      self._load_templates_for_service(service)
    act_key = get_action_template(action, intent)
    template_dict = self._templates_for_service[service]
    if act_key not in template_dict:
      raise ValueError(f"Template not defined for {act_key} for {service}.")
    template = template_dict[act_key]
    # Fill the placeholder characters in the template from action.
    value_idx = 0
    offset = 0
    for idx, char in enumerate(template):
      if char == VALUE_CHAR:
        if self._use_canonical_values:
          value = action["canonical_values"][value_idx]
        else:
          value = action["values"][value_idx]
        if schema:
          matched_slot = None
          for slot in schema["slots"]:
            if slot["name"] == action["slot"]:
              matched_slot = slot
          is_categorical = matched_slot[
              "is_categorical"] if matched_slot else True
          replacement = value if is_categorical else f"<{action['slot']}>"
        else:
          replacement = value
        value_idx += 1
      else:
        continue

      char_ind = idx + offset
      template = template[:char_ind] + replacement + template[char_ind + 1:]
      offset += len(replacement) - 1
    return template

  def get_delexicalized_utterance(self, turn, schema=None):
    """Delexicalize target utterances.

    Delexicalize the turn utterance based on given service schema, now only
    non-categorical slots would be delexicalized.
    For example, the utterance 'The restaurant is PizzaHut.' will be converted
    into 'The restaurant is <reataurant_name>.'

    Args:
      turn: turn object, containing utterance, action, slots information
      schema: SGD service schema, indicating if the slot is categorical

    Returns:
      delexicalized utterance.
    """
    delexicalized_utterance = turn["utterance"]
    for frame in turn["frames"]:
      for action in sorted(frame["actions"], key=self._act_key_fn):
        for value in action["values"]:
          matched_slot = None
          for slot in schema["slots"]:
            if slot["name"] == action["slot"]:
              matched_slot = slot
          is_categorical = matched_slot[
              "is_categorical"] if matched_slot else True
          replacement = value if is_categorical else f"<{action['slot']}>"
          delexicalized_utterance = delexicalized_utterance.replace(
              value, replacement)

      return delexicalized_utterance

  def get_robot_utterance(self, turn, schema):
    """Get the robot utterance corresponding to a turn."""
    # Use templates to generate an utterance for each action. All utterances are
    # then concatenated to give the resulting system utterance.
    utterances = []
    for frame in turn["frames"]:
      # A trick here to make the CONFIRM action's utterance natural: Add
      # "Please confirm the following details:" in the front.
      all_acts = {action["act"] for action in frame["actions"]}
      if "CONFIRM" in all_acts:
        utterances.append(CONFIRM_PREFIX)
      for action in sorted(frame["actions"], key=self._act_key_fn):
        # Get the active intent corresponding to this action.
        intent = self._get_intent(action, frame)
        utterance = self._get_utterance_for_action(frame["service"], intent,
                                                   action, schema)

        utterances.append(utterance)
    return " ".join(utterances)
